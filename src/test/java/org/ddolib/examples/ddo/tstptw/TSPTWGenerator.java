package org.ddolib.examples.ddo.tstptw;

import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

/**
 * Generate TSPTW instances with known optimal solutions.
 * The instances are generated by placing cities on a circle and sorting them in counter-clockwise order.
 * The time windows are set such that the optimal tour is the one visiting the cities in the sorted order.
 */
public class TSPTWGenerator {

    public static void main(String[] args) {
        String outputDir = "data/TSPTW/";
        for (int i = 0; i < 100; i++) {
            generateInstance(outputDir,i);
        }
    }

    public static void generateInstance(String outputDir, int id) {
        int N_CITIES = 10;
        int RADIUS = 100;
        Random random = new Random(3);

        // Step 1: Generate cities on a circle
        double[][] cities = new double[N_CITIES][2]; // (x, y) coordinates
        double[] angles = new double[N_CITIES];
        angles[0] = 0.0; // Fix city 0 at angle 0
        cities[0][0] = RADIUS; // (R, 0)
        cities[0][1] = 0.0;
        for (int i = 1; i < N_CITIES; i++) {
            angles[i] = 2 * Math.PI * random.nextDouble(); // Random angle [0, 2Ï€)
            cities[i][0] = RADIUS * Math.cos(angles[i]);
            cities[i][1] = RADIUS * Math.sin(angles[i]);
        }
        // Step 2: Sort cities 1..N-1 by DECREASING angle (counter-clockwise from city 0)
        Integer[] cityOrder = new Integer[N_CITIES];
        for (int i = 0; i < N_CITIES; i++) cityOrder[i] = i;
        Arrays.sort(cityOrder, 1, N_CITIES, Comparator.comparingDouble((Integer i) -> angles[i]).reversed());


        // Step 3: Compute distance matrix
        int[][] distanceMatrix = new int[N_CITIES][N_CITIES];
        for (int i = 0; i < N_CITIES; i++) {
            for (int j = 0; j < N_CITIES; j++) {
                double dx = cities[i][0] - cities[j][0];
                double dy = cities[i][1] - cities[j][1];
                distanceMatrix[i][j] = (int) Math.ceil(Math.sqrt(dx * dx + dy * dy));
            }
        }

        // Optimal tour value
        int optimalValue = 0;
        int[] visitTime = new int[N_CITIES];
        visitTime[cityOrder[0]] = 0;
        for (int i = 0; i < N_CITIES; i++) {
            int from = cityOrder[i];
            int to = cityOrder[(i + 1) % N_CITIES];
            optimalValue += distanceMatrix[from][to];
            if (i < N_CITIES - 1)
                visitTime[cityOrder[i + 1]] = visitTime[from] + distanceMatrix[from][to];
        }

        String filename = outputDir + String.format("/tsptw_%dcities_%d.txt",N_CITIES,id);

        System.out.println("Generated: " + filename);
        System.out.println("Optimal tour length: " + optimalValue);
        System.out.println("Visit times (earliest): " + Arrays.toString(visitTime));
        // print optimal tour
        System.out.print("Optimal tour");
        for (int i = 0; i < N_CITIES; i++) {
            System.out.print(cityOrder[i] + " ");
        }

        // Step 4: Write to file
        try (FileWriter writer = new FileWriter(filename)) {
            writer.write(N_CITIES + " " + (-optimalValue) + "\n"); // Number of cities
            for (int i = 0; i < N_CITIES; i++) {
                for (int j = 0; j < N_CITIES; j++) {
                    writer.write(distanceMatrix[i][j] + " ");
                }
                writer.write("\n");
            }
            // write time windows
            for (int i = 0; i < N_CITIES; i++) {
                int earliest = visitTime[i];
                int latest = i == 0 ? optimalValue: visitTime[i]; // allow some slack
                writer.write(earliest + " " + latest + "\n");
            }
            // write solution
            writer.write("# OptimalTour: ");
            for (int i = 0; i < N_CITIES; i++) {
                writer.write(cityOrder[i] + " ");
            }
            writer.write("\n");

        } catch (IOException e) {
            System.err.println("Error writing file: " + e.getMessage());
        }
    }

    static record Item(int value, int weight) {
        double ratio() {
            return (double) value / weight;
        }
    }
}



